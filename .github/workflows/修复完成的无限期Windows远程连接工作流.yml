name: Balanced - Windows with Remote Desktop (Unlimited Version)

on:
  workflow_dispatch:
    inputs:
      rdp_password:
        description: 'Remote Desktop Password (min 8 chars, must include uppercase, lowercase, number, and special character)'
        required: true
        type: string
      rdp_port:
        description: 'Remote Desktop Port (default: 3389)'
        required: false
        default: '3389'
        type: string

jobs:
  build:
    runs-on: windows-2022
    # ÂèñÊ∂àÂ∑•‰ΩúÊµÅË∂ÖÊó∂ÈôêÂà∂
    # timeout-minutes: 120  # Â∑≤ÁßªÈô§Êó∂Èó¥ÈôêÂà∂
    
    steps:
      - name: Initial System State
        run: |
          Write-Host "============================================="
          Write-Host "Initial System State"
          Write-Host "============================================="
          
          Write-Host "`nMemory and swap space:"
          systeminfo | Select-String "Total Physical Memory|Available Physical Memory|Virtual Memory"
          
          Write-Host "`nAvailable storage:"
          Get-PSDrive -PSProvider FileSystem | Format-Table Name, Root, @{n='FreeSpaceGB';e={[math]::Round($_.FreeSpace/1GB, 2)}}
          
          Write-Host "`nCPU Information:"
          Get-CimInstance Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors | Format-Table
        error-action: continue

      - name: Validate Input Parameters
        run: |
          Write-Host "============================================="
          Write-Host "Validating Input Parameters"
          Write-Host "============================================="
          
          # Validate password complexity
          $rdpPassword = "${{ inputs.rdp_password }}"
          $passwordRequirements = @(
              @{ Name = "Minimum length 8 characters"; Test = { $rdpPassword.Length -ge 8 } },
              @{ Name = "At least one uppercase letter"; Test = { $rdpPassword -match '[A-Z]' } },
              @{ Name = "At least one lowercase letter"; Test = { $rdpPassword -match '[a-z]' } },
              @{ Name = "At least one number"; Test = { $rdpPassword -match '[0-9]' } },
              @{ Name = "At least one special character"; Test = { $rdpPassword -match '[^a-zA-Z0-9]' } }
          )
          
          $valid = $true
          foreach ($req in $passwordRequirements) {
              if (-not & $req.Test) {
                  Write-Error "‚ùå Password validation failed: $($req.Name)"
                  $valid = $false
              } else {
                  Write-Host "‚úÖ $($req.Name)"
              }
          }
          
          if (-not $valid) {
              Write-Error "‚ùå Password does not meet complexity requirements"
              exit 1
          }
          
          # Validate port number
          $rdpPort = "${{ inputs.rdp_port }}"
          if (-not ($rdpPort -match '^\d+$') -or $rdpPort -lt 1 -or $rdpPort -gt 65535) {
              Write-Error "‚ùå Invalid port number: $rdpPort"
              exit 1
          }
          
          Write-Host "`n‚úÖ All parameters validated successfully"
        error-action: stop

      - name: Configure Remote Desktop Access
        run: |
          Write-Host "============================================="
          Write-Host "Configuring Remote Desktop Access"
          Write-Host "============================================="
          
          try {
              # Set RDP password from input
              $rdpPassword = "${{ inputs.rdp_password }}"
              $env:COMPUTERNAME = $env:COMPUTERNAME.ToUpper()
              $userName = "GitHubActionsUser"
              $rdpPort = "${{ inputs.rdp_port }}"
              
              Write-Host "`nCreating RDP user account: $userName"
              
              # Check if user already exists
              if (-not (Get-LocalUser -Name $userName -ErrorAction SilentlyContinue)) {
                  # Create new user with proper error handling
                  $securePassword = ConvertTo-SecureString $rdpPassword -AsPlainText -Force
                  New-LocalUser -Name $userName -Password $securePassword `
                                -FullName "GitHub Actions User" `
                                -Description "Unlimited user for RDP access" `
                                -ErrorAction Stop
                  
                  # Add user to Remote Desktop Users group
                  Add-LocalGroupMember -Group "Remote Desktop Users" -Member $userName -ErrorAction Stop
                  Write-Host "‚úÖ User $userName added to Remote Desktop Users group"
              } else {
                  Write-Host "‚ÑπÔ∏è  User $userName already exists, updating password"
                  $securePassword = ConvertTo-SecureString $rdpPassword -AsPlainText -Force
                  Set-LocalUser -Name $userName -Password $securePassword -ErrorAction Stop
              }
              
              # Enable Remote Desktop with proper error handling
              Write-Host "`nEnabling Remote Desktop"
              Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                              -Name "fDenyTSConnections" -Value 0 -ErrorAction Stop
              
              # Configure RDP settings for better security
              Write-Host "Configuring RDP security settings"
              Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
                              -Name "UserAuthentication" -Value 1 -ErrorAction SilentlyContinue
              
              # Allow RDP through Windows Firewall
              Write-Host "Configuring Windows Firewall for RDP"
              $firewallRule = Get-NetFirewallRule -DisplayName "Allow RDP" -ErrorAction SilentlyContinue
              if ($firewallRule) {
                  Remove-NetFirewallRule -DisplayName "Allow RDP" -ErrorAction Stop
              }
              
              New-NetFirewallRule -DisplayName "Allow RDP" `
                                 -Direction Inbound `
                                 -Protocol TCP `
                                 -LocalPort $rdpPort `
                                 -Action Allow `
                                 -RemoteAddress Any `
                                 -ErrorAction Stop
              
              # Get public IP address with retry logic
              Write-Host "`nGetting public IP address"
              $maxRetries = 3
              $retryCount = 0
              $publicIp = $null
              
              while ($retryCount -lt $maxRetries -and -not $publicIp) {
                  try {
                      $publicIp = (Invoke-RestMethod -Uri 'https://api.ipify.org?format=json' -TimeoutSec 10).ip
                  } catch {
                      $retryCount++
                      Write-Warning "Failed to get public IP (attempt $retryCount/$maxRetries): $_"
                      Start-Sleep -Seconds 2
                  }
              }
              
              if (-not $publicIp) {
                  $publicIp = "Unknown"
                  Write-Warning "‚ö†Ô∏è  Could not determine public IP address"
              }
              
              Write-Host "`n============================================="
              Write-Host "‚úÖ Remote Desktop Configuration Complete"
              Write-Host "============================================="
              Write-Host "`nüìã RDP Connection Details:"
              Write-Host "   Computer: $publicIp`:$rdpPort"
              Write-Host "   Username: $env:COMPUTERNAME\$userName"
              Write-Host "   Password: [The password you provided]"
              Write-Host "`n‚ö†Ô∏è  Note: This RDP session has NO time limit"
              Write-Host "============================================="
              
          } catch {
              Write-Error "‚ùå RDP configuration failed: $_"
              # Clean up on failure
              if (Get-LocalUser -Name "GitHubActionsUser" -ErrorAction SilentlyContinue) {
                  Remove-LocalUser -Name "GitHubActionsUser" -Force -ErrorAction SilentlyContinue
              }
              exit 1
          }
        error-action: stop

      - name: Clean Up System Space
        run: |
          Write-Host "============================================="
          Write-Host "Cleaning Up System Space"
          Write-Host "============================================="
          
          try {
              $drive = (Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root -eq 'C:\' }).Name
              $beforeFreeSpace = (Get-PSDrive $drive).FreeSpace
              
              Write-Host "`nCurrent free space on $drive`: $([math]::Round($beforeFreeSpace/1GB, 2)) GB"
              
              # Function to remove directory with better error handling
              function Remove-Directory {
                  param(
                      [string]$path,
                      [string]$name
                  )
                  
                  if (Test-Path $path) {
                      try {
                          $size = (Get-ChildItem $path -Recurse -Force -ErrorAction SilentlyContinue | 
                                   Measure-Object -Property Length -Sum -ErrorAction SilentlyContinue).Sum
                          $sizeMB = if ($size) { [math]::Round($size/1MB, 2) } else { 0 }
                          Write-Host "Removing $name ($sizeMB MB)..."
                          
                          # Use robocopy for more reliable deletion
                          robocopy /MIR "$path" "$env:TEMP\empty_dir" /NFL /NDL /NJH /NJS /NP /R:3 /W:1 | Out-Null
                          Remove-Item $path -Recurse -Force -ErrorAction Stop
                          Write-Host "‚úÖ Removed $name"
                      } catch {
                          Write-Warning "‚ö†Ô∏è  Failed to remove $name : $_"
                      }
                  } else {
                      Write-Host "‚ÑπÔ∏è  Skipping $name (not found)"
                  }
              }
              
              # Create empty directory for robocopy
              $emptyDir = "$env:TEMP\empty_dir"
              if (-not (Test-Path $emptyDir)) {
                  New-Item -ItemType Directory -Path $emptyDir -Force | Out-Null
              }
              
              # Clean up Windows components with better methods
              Write-Host "`nCleaning up Windows components..."
              
              # Clean Windows Update cache with safer method
              Write-Host "Cleaning Windows Update cache..."
              try {
                  # Use built-in cleanup instead of stopping service
                  Get-CimInstance -ClassName Win32_Service -Filter "Name='wuauserv'" | 
                  Invoke-CimMethod -MethodName StopService -Arguments @{Timeout=5000} -ErrorAction SilentlyContinue
                  
                  Remove-Directory -path "C:\Windows\SoftwareDistribution\Download\*" -name "Windows Update cache"
                  
                  Get-CimInstance -ClassName Win32_Service -Filter "Name='wuauserv'" | 
                  Invoke-CimMethod -MethodName StartService -ErrorAction SilentlyContinue
              } catch {
                  Write-Warning "‚ö†Ô∏è  Windows Update cache cleanup failed: $_"
              }
              
              # Clean Temp files
              Write-Host "Cleaning Temp files..."
              Remove-Directory -path "C:\Windows\Temp\*" -name "Windows Temp files"
              Remove-Directory -path "$env:TEMP\*" -name "User Temp files"
              
              # Clean Recycle Bin
              Write-Host "Cleaning Recycle Bin..."
              try {
                  Clear-RecycleBin -Force -ErrorAction Stop
                  Write-Host "‚úÖ Recycle Bin cleaned"
              } catch {
                  Write-Warning "‚ö†Ô∏è  Recycle Bin cleanup failed: $_"
              }
              
              # Remove unnecessary applications using better method
              Write-Host "`nRemoving unnecessary applications..."
              
              # List of applications to remove (display names)
              $appsToRemove = @(
                  "Microsoft Edge",
                  "Google Chrome",
                  "Mozilla Firefox",
                  "Git",
                  "Python",
                  "Node.js",
                  "Docker",
                  "Visual Studio Code",
                  "7-Zip",
                  "WinRAR"
              )
              
              foreach ($app in $appsToRemove) {
                  try {
                      # Use Get-Package for better package management
                      $packages = Get-Package -Name "*$app*" -ErrorAction SilentlyContinue
                      if ($packages) {
                          foreach ($package in $packages) {
                              Write-Host "Uninstalling $($package.Name)..."
                              $package | Uninstall-Package -Force -ErrorAction Stop
                              Write-Host "‚úÖ Uninstalled $($package.Name)"
                          }
                      } else {
                          Write-Host "‚ÑπÔ∏è  $app not found"
                      }
                  } catch {
                      Write-Warning "‚ö†Ô∏è  Failed to uninstall $app : $_"
                  }
              }
              
              # Clean up Windows Store apps with filtering
              Write-Host "`nCleaning up Windows Store apps..."
              try {
                  Get-AppxPackage -AllUsers | 
                  Where-Object { $_.Name -notlike "*Microsoft*" -and $_.Name -notlike "*Windows*" -and $_.NonRemovable -ne $true } | 
                  Remove-AppxPackage -ErrorAction SilentlyContinue
                  Write-Host "‚úÖ Windows Store apps cleaned up"
              } catch {
                  Write-Warning "‚ö†Ô∏è  Windows Store apps cleanup failed: $_"
              }
              
              # Clean up system files with DISM
              Write-Host "`nRunning system cleanup..."
              try {
                  DISM /Online /Cleanup-Image /StartComponentCleanup /ResetBase | Out-Null
                  Write-Host "‚úÖ System cleanup completed"
              } catch {
                  Write-Warning "‚ö†Ô∏è  System cleanup failed: $_"
              }
              
              # Remove empty directory
              if (Test-Path $emptyDir) {
                  Remove-Item $emptyDir -Recurse -Force -ErrorAction SilentlyContinue
              }
              
              $afterFreeSpace = (Get-PSDrive $drive).FreeSpace
              $freedSpace = $afterFreeSpace - $beforeFreeSpace
              $freedSpaceGB = [math]::Round($freedSpace/1GB, 2)
              
              Write-Host "`n============================================="
              Write-Host "‚úÖ Cleanup Complete"
              Write-Host "============================================="
              Write-Host "Freed up space: $freedSpaceGB GB"
              Write-Host "Current free space: $([math]::Round($afterFreeSpace/1GB, 2)) GB"
              Write-Host "============================================="
              
          } catch {
              Write-Error "‚ùå Cleanup failed: $_"
              # Continue even if cleanup has errors
          }
        error-action: continue

      - name: Check Out Code Repository
        uses: actions/checkout@v4
        continue-on-error: true

      - name: Display Optimization Results
        run: |
          Write-Host "============================================="
          Write-Host "‚úÖ System Optimization Complete"
          Write-Host "============================================="
          
          Write-Host "`nüìä System Status:"
          Write-Host "------------------------"
          
          # Display storage information
          $drive = (Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root -eq 'C:\' }).Name
          $freeSpace = [math]::Round((Get-PSDrive $drive).FreeSpace/1GB, 2)
          Write-Host "Storage (C:): $freeSpace GB free"
          
          # Display memory information
          $memoryInfo = systeminfo | Select-String "Total Physical Memory|Available Physical Memory"
          $memoryInfo | ForEach-Object { Write-Host $_.Line }
          
          # Display CPU information
          $cpuInfo = Get-CimInstance Win32_Processor | Select-Object Name, NumberOfCores
          Write-Host "`nCPU: $($cpuInfo.Name)"
          Write-Host "Cores: $($cpuInfo.NumberOfCores)"
          
          Write-Host "`n============================================="
        error-action: continue

      - name: Install and Launch Application
        run: |
          Write-Host "============================================="
          Write-Host "Installing and Launching Application"
          Write-Host "============================================="
          
          try {
              if (Test-Path "start.bat") {
                  Write-Host "Launching application using start.bat..."
                  Start-Process -FilePath "start.bat" -NoNewWindow -PassThru | Out-Null
                  Write-Host "‚úÖ Application launched successfully"
              } elseif (Test-Path "start.ps1") {
                  Write-Host "Launching application using start.ps1..."
                  Start-Process -FilePath "powershell.exe" `
                               -ArgumentList "-ExecutionPolicy Bypass -File start.ps1" `
                               -NoNewWindow -PassThru | Out-Null
                  Write-Host "‚úÖ Application launched successfully"
              } else {
                  Write-Warning "‚ö†Ô∏è  No start script found (start.bat or start.ps1). Skipping application launch."
              }
          } catch {
              Write-Warning "‚ö†Ô∏è  Application launch failed: $_"
          }
        error-action: continue

      - name: Keep Workflow Running Indefinitely
        run: |
          Write-Host "============================================="
          Write-Host "üöÄ Starting Unlimited Keep-Alive Process"
          Write-Host "============================================="
          
          try {
              $startTime = Get-Date
              
              Write-Host "`n‚è±Ô∏è  Session Type: UNLIMITED (No time restriction)"
              Write-Host "üìÖ Start Time: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))"
              Write-Host "üîÑ Session will run until manually stopped"
              
              # Get RDP connection details again for convenience
              $maxRetries = 3
              $retryCount = 0
              $publicIp = $null
              
              while ($retryCount -lt $maxRetries -and -not $publicIp) {
                  try {
                      $publicIp = (Invoke-RestMethod -Uri 'https://api.ipify.org?format=json' -TimeoutSec 10).ip
                  } catch {
                      $retryCount++
                      Write-Warning "Failed to get public IP (attempt $retryCount/$maxRetries): $_"
                      Start-Sleep -Seconds 2
                  }
              }
              
              if (-not $publicIp) {
                  $publicIp = "Unknown"
              }
              
              $rdpPort = ${{ inputs.rdp_port }}
              $userName = "GitHubActionsUser"
              
              Write-Host "`nüìã RDP Connection Details:"
              Write-Host "------------------------"
              Write-Host "Computer: $publicIp`:$rdpPort"
              Write-Host "Username: $env:COMPUTERNAME\$userName"
              Write-Host "Password: [The password you provided]"
              Write-Host "`n‚ö†Ô∏è  Important: This session has NO time limit"
              Write-Host "‚ö†Ô∏è  Session will continue until manually stopped"
              
              # Monitor session indefinitely
              $iteration = 0
              $lastNotificationTime = Get-Date
              
              while ($true) {
                  $iteration++
                  $currentTime = Get-Date
                  $elapsed = ($currentTime - $startTime).TotalHours
                  
                  # Display status every hour
                  $notificationInterval = New-TimeSpan -Hours 1
                  if (($currentTime - $lastNotificationTime) -ge $notificationInterval) {
                      $elapsedHours = [math]::Round($elapsed, 2)
                      Write-Host "`nüîÑ Session active for $elapsedHours hours (unlimited)"
                      
                      # Check RDP connections with better method
                      try {
                          $rdpSessions = qwinsta.exe 2>&1 | Select-String -Pattern "$userName"
                          if ($rdpSessions) {
                              Write-Host "üë§ Active RDP connection detected"
                          } else {
                              Write-Host "‚ö†Ô∏è  No active RDP connections"
                          }
                      } catch {
                          Write-Warning "‚ö†Ô∏è  Failed to check RDP sessions: $_"
                      }
                      
                      $lastNotificationTime = $currentTime
                  }
                  
                  # Also display status on first iteration
                  if ($iteration -eq 1) {
                      Write-Host "`nüîÑ Session started successfully"
                  }
                  
                  # Sleep for 5 minutes between checks
                  Start-Sleep -Seconds 300
              }
          } catch {
              Write-Error "‚ùå Keep-alive process failed: $_"
              exit 1
          }
        error-action: stop

      - name: Clean Up After Session
        if: always()
        run: |
          Write-Host "============================================="
          Write-Host "üßπ Cleaning Up After Session"
          Write-Host "============================================="
          
          try {
              # Remove RDP user
              $userName = "GitHubActionsUser"
              if (Get-LocalUser -Name $userName -ErrorAction SilentlyContinue) {
                  Write-Host "Removing RDP user: $userName"
                  Remove-LocalUser -Name $userName -Force -ErrorAction Stop
                  Write-Host "‚úÖ RDP user removed"
              }
              
              # Disable RDP
              Write-Host "Disabling Remote Desktop"
              Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                              -Name "fDenyTSConnections" -Value 1 -ErrorAction Stop
              Write-Host "‚úÖ Remote Desktop disabled"
              
              # Remove RDP firewall rule
              Write-Host "Removing RDP firewall rule"
              $firewallRule = Get-NetFirewallRule -DisplayName "Allow RDP" -ErrorAction SilentlyContinue
              if ($firewallRule) {
                  Remove-NetFirewallRule -DisplayName "Allow RDP" -ErrorAction Stop
                  Write-Host "‚úÖ RDP firewall rule removed"
              }
              
              Write-Host "`n‚úÖ Cleanup completed successfully"
          } catch {
              Write-Error "‚ùå Cleanup failed: $_"
              # Continue even if cleanup has errors
          }
        error-action: continue